
# #
# Generates the symbol table from an AST creatd by the
#     reader. It handles erros related to the symbol table.
#
# @param modules is the abstract syntax tree created by
#     the reader from the input file.
#
def getSymbolTable (modules):
  symbolTable = {}
  offset = 0

  # loop through each module.
  for i in range(0,len(modules)):
    module = modules[i]
    definitions = module["definitionMap"]
    moduleLength = len(module["programInstructions"])
    # go through each definition in each definition map for this module.
    for definition in definitions:
      # make sure the definition is in the bounds of the module.
      if definitions[definition] > (len(module["programInstructions"]) - 1):
        definitions[definition] = 0
        print("Error: Definition of " + definition + " exceeds the size of module " + str(i+1))

      # make sure the variable has not already been defined.
      if not symbolTable.has_key(definition):
        symbolTable[definition] = definitions[definition] + offset
      else:
        print("Error: Cannot define a symbol twice.")

    offset += moduleLength

  return symbolTable


# #
# Generates the memory map given an AST of the input file
#     and the symbolTable. This would be the "2nd pass".
#
# @param ms The Abstract Syntax tree generated by the reader
#     from the input file. It's is a python dictionary.
# @param symbolTable A Dictionary created by getSymbolTable.
#
def getMemoryMap (ms, symbolTable):
  memoryMap = {}
  count = 0
  offset = 0
  symbolsUsed = []

  for i in range(0,len(ms)):
    for use in ms[i]["usageMap"]:
      indexOfUse = int(ms[i]["usageMap"][use])

      # check to confirm that the index is not out of the scope of the instructions.
      if indexOfUse > (len(ms[i]["programInstructions"])+1):
        print("Error: Use of " + use + " outside the bouds of module " + i)
        indexOfUse = 0

      indexOfNextUse = ms[i]["programInstructions"][indexOfUse]["address"]
      symbolsUsed.append(use)

      # make sure the variable has been defined in the symbol table.
      if not symbolTable.has_key(use):
        useValue = 0
        print("Error: Undefined Variable '" + use + "' was used.")
      else:
        useValue = symbolTable[use]

      ms[i]["programInstructions"][indexOfUse]["address"] = useValue

      # follow the linked list of pointers until you hit 777.
      while indexOfNextUse != 777:
        
        # make sure the linked list doesn't point to non-external instructions.
        if ms[i]["programInstructions"][indexOfUse]["type"] is not "E":
          print("Error: Address on a use list is not of type E")
          ms[i]["programInstructions"][indexOfUse][type] = "E"

        # confirm that the next use is within the bounds of the program.
        if len(ms[i]["programInstructions"]) > indexOfNextUse:
          tmp = ms[i]["programInstructions"][indexOfNextUse]["address"]
          ms[i]["programInstructions"][indexOfNextUse]["address"] = useValue
          indexOfNextUse = tmp
        else:
          print("Error: Pointer in use chain exceeds module size; chain terminated.")
          indexOfNextUse = 777
    # loop through all of the instructions in this module
    for j in range(0, len(ms[i]["programInstructions"])):
      instruction = ms[i]["programInstructions"][j]

      # add them to the memory map based on their type. External's have already been adjusted.
      if instruction["type"] is "I" or instruction["type"] is "A" or instruction["type"] is "E":
        memoryMap[count] = (instruction["opcode"]*1000) + instruction["address"]
      elif instruction["type"] is "R":
        memoryMap[count] = (instruction["opcode"]*1000) + instruction["address"] + offset
      else:
        print("Error: Invalid Letter")

      count+=1

    offset = count


  # retrospectively check that all defined symbols were used.
  for symbol in symbolTable:
    if symbol not in symbolsUsed:
      print("Warning: Symbol " + symbol + " was defined and not used")

  return memoryMap



